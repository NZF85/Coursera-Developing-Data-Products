Model1<-lm(mpg ~ qsec + wt*am, data=mtcars)
summary(Model1)
summary(Model1)$coeff
anova(fullModel,stepModel,Model1)
Model2<-lm(mpg ~ qsec*am + wt, data=mtcars)
Model3<-lm(mpg ~ qsec*wt + am, data=mtcars)
Model4<-lm(mpg ~ qsec*wt*am, data=mtcars)
anova(fullModel,stepModel,Model1,Model2,Model3,Model4)
par(mfrow=c(2, 2))
plot(Model1)
summary(Model1)
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
ggplot(data = training, aes(x = Superplasticizer)) + geom_histogram() + theme_bw()
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
ggplot(data = mtcars, aes(y = mpg, x = am)) +
geom_boxplot(aes(fill = am)) +
geom_jitter(aes(color = wt), size=4) +
ggtitle("Plot 2: Miles per gallon by Transmission type")+
theme_bw()
View(mtcars)
View(mtcars)
data(mtcars)
mtcars$cyl <- factor(mtcars$cyl)
mtcars$vs <- factor(mtcars$vs, labels=c('V-Engine','Straight'))
mtcars$gear <- factor(mtcars$gear)
mtcars$carb <- factor(mtcars$carb)
mtcars$am <- factor(mtcars$am,labels=c('Automatic','Manual'))
View(mtcars)
View(mtcars)
corr
corr<-cor(mtcars)
data(mtcars)
corr<-cor(mtcars)
corr
diag(corr)<-0
diag(corr)<-0
corr
plot(mtcars$cyl,mtcars$disp)
boxplot(mtcars$cyl,mtcars$disp)
plot(mtcars$cyl,mtcars$disp)
library(ggplot2)
ggplot(data = mtcars, aes(y = cyl, x = disp)) +
geom_boxplot(aes(fill = as.factor(am))) +
geom_jitter() +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = cyl, x = disp)) +
##geom_boxplot(aes(fill = as.factor(am))) +
geom_jitter() +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = cyl, x = disp)) +
##geom_boxplot(aes(fill = as.factor(am))) +
geom_jitter() +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot() +
geom_jitter() +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter() +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt, size=4)) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt, size=8)) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt, size=85)) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt), size =4) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt), size =8) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt), size =6) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
ggplot(data = mtcars, aes(y = disp, x = cyl)) +
geom_boxplot(aes(fill = as.factor(cyl))) +
geom_jitter(aes(color = wt), size =4) +
ggtitle("Plot 2: Cyl vs Disp")+
theme_bw()
View(corr)
set.seed(3433)
library(AppliedPredictiveModeling)
data(AlzheimerDisease)
adData = data.frame(diagnosis, predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[inTrain, ]
testing = adData[-inTrain, ]
IL_str <- grep("^IL", colnames(training), value = TRUE)
preProc <- preProcess(training[, IL_str], method = "pca", thresh = 0.9)
preProc$rotation
install.packages("shiny")
library(shiny)
runExample("01_hello")
library(shiny)
setwd("C:/Users/user/Desktop/Coursera/Data products")
# Load required libraries
require(data.table)
# library(sqldf)
library(dplyr)
library(DT)
library(rCharts)
# Read data
data <- fread("./UNdata_Export_20150919_104759402.csv")
data
View(data)
sum(is.na(data)) # 0
length(unique(data$Country/Area)) # 10418
setnames(data, "Country or Area", "Country/Area")
length(unique(data$Country/Area)) # 10418
View(data)
setnames(data, "Country or Area", "Country")
length(unique(data$Country)) # 10418
length(table(data$Year)) # 64
table(data$Year) # 1950 - 2015
length(table(data$Country)) # 101
View(data)
setnames(data, "Country/Area", "Country")
View(data)
length(table(data$Country)) # 101
Country <- sort(unique(data$tCountry))
table(data$Country)
ource)
table(data$Source) # 1995 - 2015
length(table(data$Source)) # 17
Source <- sort(unique(data$Source))
table(data$Type)
table(data$Type)
setnames(data, "Source Type", "SourceType")
table(data$SourceType)
SourceType <- sort(unique(data$SourceType))
length(table(data$SourceType)) # 2
Rate
Year
Year <- sort(unique(data$Year))
Year
Rate<- date$Rate
Rate<- data$Rate
result <- dt %>% filter(Year >= minYear, Year <= maxYear,
Rate >= minRate, Rate <= maxRate,
Country %in% Country)
}
# Load required libraries
require(data.table)
# library(sqldf)
library(dplyr)
library(DT)
library(rCharts)
# Read data
data <- fread("./UNdata_Export_20150919_104759402.csv")
head(data)
setnames(data, "Country or Area", "Country")
setnames(data, "Source Type", "SourceType")
# Exploratory data analysis
sum(is.na(data)) # 0
table(data$Year) # 1995 - 2015
length(table(data$Year)) # 17
Year <- sort(unique(data$Year))
length(table(data$Country)) # 206
Country <- sort(unique(data$Country))
table(data$Source)
length(table(data$Source)) # 28
Source <- sort(unique(data$Source))
table(data$SourceType)
length(table(data$SourceType)) # 2
SourceType <- sort(unique(data$SourceType))
## Helper functions
#' Aggregate dataset by year
#'
#' @param dt data.table
#' @param minYear
#' @param maxYear
#' @param minRate
#' @param maxRate
#' @param Country
#' @return data.table
#'
groupByYearRate <- function(dt, minYear, maxYear, minRate,
maxRate, Country) {
result <- dt %>% filter(Year >= minYear, Year <= maxYear,
Rate >= minRate, Rate <= maxRate,
Country %in% Country)
return(result)
}
#' Aggregate dataset by Source
#'
#' @param dt data.table
#' @param minYear
#' @param maxYear
#' @param minRate
#' @param maxRate
#' @param Source
#' @return result data.table
#'
groupBySource <- function(dt, minYear, maxYear,  minRate,
maxRate, Source) {
dt <- groupByYearRate(dt, minYear, maxYear, minRate, maxRate, Source)
result <- datatable(dt, options = list(iDisplayLength = 50))
return(result)
}
#' Aggregate dataset by year to get total count of countries
#'
#' @param dt data.table
#' @param minYear
#' @param maxYear
#' @param minRate
#' @param maxRate
#' @param Country
#' @return data.table 2 columns
#'
groupByYearAgg <- function(dt, minYear, maxYear, minRate,
maxRate, Country) {
dt <- groupByYearRate(dt, minYear, maxYear, minRate,
maxRate, Country)
result <- dt %>%
group_by(Year)  %>%
summarise(count = n()) %>%
arrange(Year)
return(result)
}
#' Aggregate dataset by year to get total count of average
#' number of Source
#'
#' @param dt data.table
#' @param minYear
#' @param maxYear
#' @param minRate
#' @param maxRate
#' @param Source
#' @return data.table 2 columns
#'
groupBySourceAvg <- function(dt,  minYear, maxYear, minRate,
maxRate, Source) {
dt <- groupByYearRate(dt, minYear, maxYear, minRate,
maxRate, Source)
result <- dt %>%
group_by(Year) %>%
summarise(avg = mean(Source)) %>%
arrange(Year)
return(result)
}
#' Average Sources for each Country
#'
#' @param dt data.table
#' @param minYear
#' @param maxYear
#' @param minRate
#' @param maxRate
#' @param Source
#' @return data.table 2 columns
#'
groupByPieceSourceAvg <- function(dt,  minYear, maxYear, minRate,
maxRate, Source) {
dt <- groupByYearRate(dt, minYear, maxYear, minRate,
maxRate, Source)
result <- dt %>%
group_by(Source) %>%
summarise(avgRate = mean(Rate)) %>%
arrange(Source)
return(result)
}
#' Plot number of sources by year
#'
#' @param dt data.table
#' @param dom
#' @param xAxisLabel year
#' @param yAxisLabel number of sources
#' @return SourceByYear plot
plotSourceCountByYear <- function(dt, dom = "SourceByYear",
xAxisLabel = "Year",
yAxisLabel = "Number of Source") {
SourceByYear <- nPlot(
count ~ year,
data = dt,
#type = "lineChart",
type = "multiBarChart",
dom = dom, width = 650
)
SourceByYear$chart(margin = list(left = 100))
SourceByYear$yAxis(axisLabel = yAxisLabel, width = 80)
SourceByYear$xAxis(axisLabel = xAxisLabel, width = 70)
SourceByYear
}
#' Plot number of Rate by year
#'
#' @param dt data.table
#' @param dom
#' @param xAxisLabel year
#' @param yAxisLabel number of Rate
#' @return plotRateByYear plot
plotRateByYear <- function(dt, dom = "RateByYear",
xAxisLabel = "Year",
yAxisLabel = "Number of Rate") {
RateByYear <- nPlot(
Rate ~ year,
data = dt,
#         group = "year",
type = "scatterChart",
dom = dom, width = 650
)
RateByYear$chart(margin = list(left = 100),
showDistX = TRUE,
showDistY = TRUE)
RateByYear$chart(color = c('green', 'orange', 'blue'))
RateByYear$chart(tooltipContent = "#! function(key, x, y, e){
return '<h5><b>Set Name</b>: ' + e.point.name + '<br>'
+ '<b>Set ID</b>: ' + e.point.setId
+ '</h5>'
} !#") # data[data$Rate==y&data$year==x, ]$name
RateByYear$yAxis(axisLabel = yAxisLabel, width = 80)
RateByYear$xAxis(axisLabel = xAxisLabel, width = 70)
#     RateByYear$chart(useInteractiveGuideline = TRUE)
RateByYear
}
#' Plot number of average Rate by year
#'
#' @param dt data.table
#' @param dom
#' @param xAxisLabel year
#' @param yAxisLabel number of Rate
#' @return SourceByYear plot
plotRateByYearAvg <- function(dt, dom = "RateByYearAvg",
xAxisLabel = "Year",
yAxisLabel = "Number of Rate") {
RateByYearAvg <- nPlot(
avg ~ year,
data = dt,
type = "lineChart",
dom = dom, width = 650
)
RateByYearAvg$chart(margin = list(left = 100))
RateByYearAvg$chart(color = c('orange', 'blue', 'green'))
RateByYearAvg$yAxis(axisLabel = yAxisLabel, width = 80)
RateByYearAvg$xAxis(axisLabel = xAxisLabel, width = 70)
RateByYearAvg
}
#' Plot number of average pieces by Source
#'
#' @param dt data.table
#' @param dom
#' @param xAxisLabel Source
#' @param yAxisLabel number of pieces
#' @return piecesBySourceAvg plot
plotPiecesBySourceAvg <- function(dt, dom = "piecesBySourceAvg",
xAxisLabel = "Source",
yAxisLabel = "Number of Pieces") {
piecesBySourceAvg <- nPlot(
avgPieces ~ Source,
data = dt,
type = "multiBarChart",
dom = dom, width = 650
)
piecesBySourceAvg$chart(margin = list(left = 100))
piecesBySourceAvg$chart(color = c('pink', 'blue', 'green'))
piecesBySourceAvg$yAxis(axisLabel = yAxisLabel, width = 80)
piecesBySourceAvg$xAxis(axisLabel = xAxisLabel, width = 200,
rotateLabels = -20, height = 200)
piecesBySourceAvg
}
runApp()
You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.
---
title: "test2"
runtime: shiny
output: html_document
---
This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.
To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).
## Inputs and Outputs
You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.
```{r, echo=FALSE}
inputPanel(
selectInput("n_breaks", label = "Number of bins:",
choices = c(10, 20, 35, 50), selected = 20),
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
```
## Embedded Application
It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:
```{r, echo=FALSE}
shinyAppDir(
system.file("examples/06_tabsets", package="shiny"),
options=list(
width="100%", height=550
)
)
```
Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.
You can also use the `shinyApp` function to define an application inline rather then in an external directory.
In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.
---
title: "test2"
runtime: shiny
output: html_document
---
This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.
To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).
## Inputs and Outputs
You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.
```{r, echo=FALSE}
inputPanel(
selectInput("n_breaks", label = "Number of bins:",
choices = c(10, 20, 35, 50), selected = 20),
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
```
## Embedded Application
It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:
```{r, echo=FALSE}
shinyAppDir(
system.file("examples/06_tabsets", package="shiny"),
options=list(
width="100%", height=550
)
)
runExample("01_hello")
setwd("C:/Users/user/Desktop/Coursera/Data products test")
runApp()
library(DT)
install.packages("DT")
runApp()
runApp()
runApp()
runApp()
setwd("C:/Users/user/Desktop/Coursera/Data products")
runApp()
runApp()
View (Rate)
max(Rate)
min(Rate)
table(data$Count)
length(table(data$Count))
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
data <- fread("./UNdata_Export_20150919_104759402.csv")
head(data)
setnames(data, "Country or Area", "Country")
setnames(data, "Source Type", "SourceType")
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
is.character(data$Rate)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
exit
end()
